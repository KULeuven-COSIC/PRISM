import time

from sage.all import (
    randint,
    EllipticCurve,
    floor,
    sqrt,
    ZZ, gcd
)

from utilities.sum_of_squares import sum_of_squares
from utilities.logging_helper import logging

logger = logging.getLogger(__name__)

def FullrepresentInteger(M, p, TrulyRandom = True, primitive = False):
    r"""
    Given an integer M >p, it finds a, b, c, d such that
    N(a + b *i  + c *j + d * k) == M

    TrulyRandom is set as True by default.
    Set it to False to add some conditions, made to avoid diagonal isogenies in FixedDegree

    References: [DLLW23, Alg 1]
    """
    assert M > p
    init_time = time.time()
    four_Mp = 4 * M / p
    mp = floor(sqrt(four_Mp))
    count = 0
    while True:
        z = randint(-mp, mp)
        mpp = floor(sqrt(four_Mp - z ** 2))
        t = randint(-mpp, mpp)
        Mp = 4 * M - p * (z ** 2 + t ** 2)
        sol = sum_of_squares(Mp)
        count += 1
        if sol != []:
            x, y = sol
            x, y = ZZ(x), ZZ(y)
            if (x - t)%2 == 0 and (z - y)%2 == 0:
                if (not primitive) or gcd([(x-t)//2,(y-z)//2,z,t])==1:
                    if TrulyRandom:
                        break
                    else:
                        if ((x-t)//2)%2 == 1 and ((z-y)//2)%2 ==1:
                            break
    #NB: (x+yi+zj+tk)/2 represents the element
    # (x', y', z', t') in O0 with z'=z, t'=t, y'=(y-z)/2, x'=(x-t)/2

    logger.debug2(f"FullRepresentInteger({ZZ(M).nbits()}b, TrulyRandom={TrulyRandom}, primitive={primitive}): {count} tries, {(time.time() - init_time):.3f}s")
    x, y, z, t = ZZ(x)/ZZ(2), ZZ(y)/ZZ(2), ZZ(z)/ZZ(2), ZZ(t)/ZZ(2)
    return x, y, z, t

def RepresentInteger(M, p, TrulyRandom = True, primitive = False, verbose=False):
    r"""
    Given an integer M >p, it finds a, b, c, d INTEGERS
    such that N(a + b *i  + c *j + d * k) == M

    TrulyRandom is set as True by default.
    Set it to False to add some conditions, made to avoid diagonal isogenies in FixedDegree

    References: [2020/1240, Alg 1]
    """
    assert M > p
    init_time = time.time()
    Mp = ZZ(M) / ZZ(p)
    mp = floor(sqrt(Mp))
    count = 0
    while True:
        z = randint(-mp, mp)
        mpp = floor(sqrt(Mp - z ** 2))
        t = randint(-mpp, mpp)
        new_Mp = M - p * (z ** 2 + t ** 2)
        sol = sum_of_squares(new_Mp)
        count += 1
        if sol != []:
            x, y = sol
            x, y = ZZ(x), ZZ(y)
            if x**2 + y**2 + p * (z**2 + t**2) == M:
                break
            else:
                if verbose:
                    print('RepresentInteger iteration failed')

    #NB: (x+yi+zj+tk)/2 represents the element
    # (x', y', z', t') in O0 with z'=z, t'=t, y'=(y-z)/2, x'=(x-t)/2

    logger.debug2(f"FullRepresentInteger({ZZ(M).nbits()}b, TrulyRandom={TrulyRandom}, primitive={primitive}): {count} tries, {(time.time() - init_time):.3f}s")
    x, y, z, t = ZZ(x), ZZ(y), ZZ(z), ZZ(t)
    return x, y, z, t

def iota(P):
    F = P.base_ring()
    E = P.curve()
    # Ensure we're on the right curve
    assert E == EllipticCurve(F, [1, 0])

    # Ensure the gen is sqrt -1
    i = F.gen()
    assert i**2 == -1

    return E(-P[0], i * P[1], P[2])


def pi(P):
    F = P.base_ring()
    E = P.curve()

    # Ensure we're on the right curve
    assert E == EllipticCurve(F, [1, 0])

    p = F.characteristic()
    return E(P[0] ** p, P[1] ** p, P[2] ** p)

def check_endomorphism(P1, P2, Q1, Q2):
    r"""
    We are given a (2,2)-kernel <(P1, P2), (Q1, Q2)>.
    The functions checks whether this kernel correspond to an endomorphism on E0 x E0
    """
    if (P1 == P2) and (Q1 == Q2):
        return 1

    if (iota(P1) == P2) and (iota(Q1) == Q2):
        return 2

    return False

def evaluate_endomorphism_type(type_end, T1, T2):
    r"""
    #Given the type of endomorphism, this function evaluates
    #the endomorphism at (T1, T2)
    """
    if type_end == 1:
        return T1 + T2, T1 - T2
    else:
        iota_T1 = iota(T1)
        return iota_T1 + T2, iota_T1 - T2

def check_diagonal_isogeny(P1, P2, Q1, Q2):
	r"""
	Given a (2,2)-isogeny kernel, check whether it is the kernel of a diagonal isogeny
	this happens when one of the points is zero.

	INPUT: P1, P2, Q1, Q2, points such that (P1,P2), (Q1, Q2) is a basis of the kernel.

	OUTPUT:
	- is_diagonal: boolean value which is True if and only if the isogeny is diagonal;
	- R1, R2: if type>0, points such that the kernel is generated by (R1,0) and (0,R2).
	"""

	if P1 == 0 or Q2 == 0:
		return True, Q1, P2
	elif P2 == 0 or Q1 == 0:
		return True, P1, Q2
	else:
		return False, 0, 0

def diagonal_isogeny(R1,R2):
	r"""
	Given the kernel of a diagonal (2,2)-isogeny f, returns the diagonal components of
	this isogeny.

	INPUT: R1, R2, points such that (R1,0) and (0,R2) generate the ker(f).

	OUTPUT: diagonal component isogenies phi1, phi2, such that:
	f: (P,Q) |--> (phi1(P),phi2(Q)).
	"""
	E1 = R1.curve()
	E2 = R2.curve()

	φ1 = E1.isogeny(R1, degree = 2, model = "montgomery")
	φ2 = E2.isogeny(R2, degree = 2, model = "montgomery")

	return φ1, φ2
